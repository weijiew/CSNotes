# 1.0 数据库

## 1.1 什么是数据库？表又是什么？

数据是描述事物的**符号记录**，数据的含义称为数据的**语义**，数据和其语义**不可分割**。

数据库是保存存储数据的容器，数据库里面有很多张表，表是结构化的文件用来储存具体信息。

表中存在很多行，每一行代表一条数据，同时也有很多列，每一列代表一个字段，一个或多个列组成了表。

数据库管理系统：再存储数据库的基础上增添了很多功能，建立，存储，维护，操纵。

数据库系统： 数据，数据库，数据库管理系统的合集。

## 1.2 什么是模式？

数据库和表的布局以及特征的信息称为模式。

- 模式是相对稳定的，而实例是相对变动的。
- 一个书库只能有一个内模式和模式，但可以有多个外模式。
- 数据库的三级模式：内模式，模式，外模式。

## 1.3 主键

一张表中需要存在一个可以唯一表示的列，这个列称为主键，任何一个字段都可以作为主键，但是必须满足主键不能为空且主键必须唯一的性质。

> 如果多条 sql 语句需要在结尾加上分号(;) 单条可以不加，有些数据库可能需要加，所以最好加上！
> sql 语句大小写都行，但是开发人员喜欢关键字大写而列名表名小写，这样便于调试阅读。

## 1.4 数据库的发展阶段

- 人工管理阶段
- 文件系统
- 数据库系统

三者的**特点**：

- 人工管理阶段： 数据无法长期保存，数据冗余大，不具备可移植性，独立性差（不具备泛型）。
- 文件系统： 数据可以长期保存，但是数据冗余大，数据独立性差的问题仍然存在。
- 数据库系统： 数据可以长期保存，冗余度低，可共享，独立性高。
- 从文件系统到数据库系统标志着数据管理技术的飞跃。

## 1.5 数据模型
- 概念模型：用于设计数据库。
特点：实体，属性，码，实体型，联系。
- 逻辑（物理）模型：用于管理数据库。
特点：数据结构，数据操作，数据完整性约束。
常用数据模型：
- 层次模型：有且只有一个节点没有双亲节点称为根节点。除根节点以外的其他节点有且只有一个双亲节点。
- 网状模型：一个节点可以有多个双亲，允许多个节点无双亲。
- 关系模型
- 对象关系模型
- 版结构化数据模型

# 第二章：关系数据库

## 关系的定义

- 域：相同数据元素的集合。例如整数，偶数的概念。
- 笛卡儿积：关于域的运算，其中的一条数据称为元组，元组中的属性称为分量。
- 关系：域和域之间的关系，关系分为一元关系和多元关系，而关系是笛卡儿积的子集。
- 主码：可以唯一标识某个元组（一条数据）的属性。
- 关系的性质：
    a. 同列的数据类型相同且来自同一个域。
    b. 不同列可出自同一个域。
    c. 列序行序可变。
    d. 主码是独一无二的。
    e. 分量必须是原子值，即不允许表中套表。

> 2020/1/3

## 数据的操作：

### 操作方式：
- 查询：选择，投影，并，差，笛卡儿积
- 插入
- 删除
- 修改
- 特点： 针对集合，操作对象和结果都是集合。
- 分类： 关系代数，关系演算，结构化查询。
### 关系的完整性
- 实体完整性：必须要有主键，唯一且不为空。
- 参照完整性：实现了表于表之间的联系，取值可以为空或者为另一张表的值。
- 用户定义完整性：用户针对某些属性设定限制，例如性别为男女。
### 关系代数
- 三大要素：运算对象，运算符，运算结果。
- 传统的集合运算：并，差，交，笛卡儿积。
- 专门的关系运算：选择，投影，连接，除。
- 选择： 从行的角度针对某个属性进行的查询结果。
- 投影： 从列的角度进行查询。

# 数据库语言SQL

## 概述

### 产生与发展
- 创始：由Boyce和Chamberlin提出，IBM研制。
- 特点：集数据查询，数据操纵，数据定义，数据控制与一体。
- 非过程化语言，面向集合操纵，语法结构统一，语言简洁。
## 数据定义
- 一个数据库管理系统实例可以创建多个数据库，一个数据库可以创建多个模式，一个模式下通常包含多个表，视图和索引。
### 创建
模式的定义和删除
模型：
```sql
// 为指定用户创建模式。
CREATE SCHEMA "模式名" AUTHORIZATION 用户名;
// 如果没有指名，默认模式名为用户名。
CREATE SCHEMA AUTHORIZATION 用户名;
```
例子：
```sql
// 指定为用户 WANG 创建 S-T 模式
CREATE SCHEMA "S-T" AUTHORIZATION WANG;
// 如果没有指定模式名，则默认为用户名。
CREATE SCHEMA AUTHORIAZTION WANG;
CREATE SCHEMA "S-T" AUTHORIZATION WANG;
CREATE SCHEMA "PP" AUTHORIZATION WANG;
CREATE SCHEMA "QQ" AUTHORIZATION WANG;
CREATE SCHEMA "PP" AUTHORIZATION WANG;
CREATE SCHEMA "QQ" AUTHORIZATION WANG;
```
**删除：**
模型:
- CASCADE: 级联删除，删除下面全部关于这个模式的所有表。
- RESTRICT: 先查看当前模式下是否定义了数据对象，如果有则不执行删除，反之删除。
```sql
DROP SCHEMA 模式名 CASCADE/RESTRICT
DROP TABLE 表名 CASCADE/RESTRICT
```
例子：
```sql
DROP SCHEMA SS CASCADE;
DROP SCHEMA KK CASCADE;
DROP SCHEMA QQ CASCADE;
DROP SCHEMA CN CASCADE; 
DROP SCHEMA S-T CASCADE;
DROP SCHEMA PP RESTRICT;
DROP SCHEMA KK RESTRICT;
DROP SCHEMA QQ RESTRICT;
DROP SCHEMA CN RESTRICT;
DROP SCHEMA S-T RESTRICT; 
DROP TABLE STUDENT CASCADE;
DROP TABLE COURSE CASCADE;
DROP TABLE WORK RESTRICT; 
```
### 表的定义
模型：
```sql
CREATE TABLE 表名(
    字段名 字段类型 约束（可以不填），
    字段名 字段类型 约束 ,
    //主键约束，
    PRIMARY KEY (当前表中属性名);
    //外键约束
    FOREIGN KEY (当前表中属性名) REFERENCES 另外一张表名（表中属性名）
    //注意结尾没有逗号
);
```
例子：
```sql
CREATE TABLE STUDENTS(
    Sno CHAR(9) PRIMARY KEY,
    Sna CHAR(20) UNIQUE, 
    Ssex CHAR(2) ,
    PRIMARY KEY (Sno),
    FOREIGN KEY (Sno) REFERENCES WEIJIE(Wno),
    FOREIGN KEY (Sna) REFERENCES WEIJIE(Wname)
);
CREATE TABLE WEIJIE(
    Wno CHAR(12) PRIMARY KEY,
    Wname CHAR(20) NOT NULL,
    Whight FLOAT,
    Wweight FLOAT
);
CREATE TABLE COURSE(
    Cno CHAR(20) PRIMARY KEY,
    Cname CHAR(10) ,
    Cpno CHAR(20) ,
    Ccredit int 
);
CREATE TABLE TAB(
    COL1 CHAR(20) PRIMARY KEY,
    COL2 CHAR(20) ,
    COL3 INT
);
```
### 数据查询
模型
```sql
SELECT 属性名
FROM 表明
WHERE 限制条件
```
例子
```sql
// 3.16 查询全体学生的学号和姓名
SELECT Sno ,Sname
FROM Student;
// 3.17 查询全体学生的学号，姓名，系别
SELECT Sno,Sname,Sdept
FROM Student;
// 3.18 查询全体学生的所有记录
SELECT * 
FROM Student;
// 3.19 查询经过计算后的值
SELECT Sname,2020-Sage
FROM Student;
// 3.20 
SELECT Sname,"Birthday :" ,2014 - Sage,LOWER(Sdept)
FROM Student;
// 指定别名
SELECT Sname,"Birth :" Birthday , 2014 - Sage,LOWER(Sdept)
FROM Student;
// 3.21 查询选修课程的学生号
SELECT Sno 
FROM SC;
// 消除重复行
SELECT DISTINCT Sno
FROM SC;
// 3.22 限制条件
SELECT Sname
FROM SC;
WHERE Sdept = 'CS';
// 3.23 例子
SELECT Sname , Sage
FROM Student
WHERE Sage < 20;
// 3.24 例子
SELECT DISTINCT Sno
FROM SC
WHERE Grade < 60;
// 3.25 例子
SELECT Sname , Sdept , Sage
FROM Student
WHERE Sage  BETWEEN 20 AND 23;
// 3.26 例子
SELECT Sname , Sdept , Sage
FROM Student
WHERE Sage NOT BETWEEN 20 AND 23;
// 3.27 例子
SELECT Sname , Ssex
FROM Student
WHERE Sdept IN ('CS','MA','IS');
// 3.28 例子
SELECT Sname ,Ssex
FROM Student
WHERE Sdept NOT IN ('CS','MA','IS');
// 字符串匹配
% : 代表任意长度。
_ : 代表长度为一。
// 3.29
SELECT * 
FROM Student
WHERE Sno = "1234567898";
// 3.30
SELECT *
FROM Student
WHERE SNAME = "魏%";
// 3.31
SELECT *
FROM Student
WHERE SNAME = "欧阳_";
// 3.32
SELECT *
FROM Student
WHERE SNAME = "_阳%";
// 3.33
SELECT *
FROM Student
WHERE SNAME NOT LIKE "_阳%";
// 3.34 查询DB_design \ 为换码字符，表示后面一位不是通配符。
SELECT Cno,Credit 
FROM Course
WHERE Cname LIKE 'DB\_design';
// 3.39 ORDER BY 某列属性升序或降序排列 , DESC 降序。
SELECT Sno , Grade
FROM SC 
WHERE Cno = '3'
ORDER BY Grade DESC;
// 3.40 按照系号升序，年龄降序排列
SELECT *
FROM Student 
ORDER BY Sdept , Sage DESC;
// 3.41 聚集函数，统计个数
SELECT COUNT(*)
FROM Student;
// 3.42 剔除重复，计算个数
SELECT COUNT(DISTINCT Sno)
FROM SC;
// 3.43 AVERAGE
SELECT AVG(Grade)
FROM SC
WHERE Cno = '1';
```
### 数据更新
```sql
// 上下匹配
INSERT 
INTO Student (Sno,Sname,Ssex,Sdept,Sage)
VALUES()
```
例子
```sql
// 上下匹配
INSERT 
INTO Student (Sno,Sname,Ssex,Sdept,Sage)
VALUES('123456','王王','男','CS','25')
```
### 修改数据
模型
```sql
UPDATE 表名
SET 列名
WHERE 条件
```
例子
```sql
UPDATE Student
SET Sage = 20
WHERE Sno = '123456';
```
### 修改表
模型
```sql
ALTER TABLE 表名 具体修改
```
例子
```sql
// 增加一列数据，默认为空
ALTER TABLE Student ADD s_entrance DATE;
// 增加一个约束
ALTER TABLE Course ADD UNIQUE(Cname);
// 修改列的数据类型
ALTER TABLE Course ALTER COLUMN Sage INT;
ALTER TABLE Course ADD 
```
### 视图
我所理解的视图： 提前定义好的查询，可以直接用，简化了查询，针对视图还可以再次进行查询。
创建视图：
模型：
```sql
CREATE VIEW 视图名
AS
查询
```
例子：
```sql
CREATE VIEW ALL_STUDENT
AS 
SELECT *
FROM Student
WHERE Sdept = "CS";
```
删除视图：
```sql
//模型
DROP VIEW 视图名
// 例子
DROP VIEW ALL_STUDENT;
DROP VIEW SSS;
```
查询视图
```sql
SELECT Sno 
FROM ALL_STUDENT // 视图名
WHERE Sage < 20 ;
```
更新视图
```sql
UPDATE ALL_STUDENT 
SET Sname = '张三'
WHERE Sno = '123456';
```
```sql
// 作用：针对当前视图进行的插入，修改，删除时要保证满足视图定义中的谓词条件。
with check option
```
# 数据库安全
## 用户身份鉴别：
- 静态口令鉴别
- 动态口令鉴别
- 生物特征鉴别
- 智能卡鉴别
## 多层存取控制：
- 自主存取控制：
    自定义，不同用户不同权限，权限可以转给别人。
- 强制存取控制
    对数据对象设定等级，等级之下不能使用等级之上的权限，拥有当前等级的权限同时拥有当前等级之下的权限。
## 自主存取控制
```sql
//授予 with garnt option 可以把当前权限授予给别人
grant select on table student to u1 with grant option;
grant insert on table student to u2;
//取消 cascade取消了u1授予给别人的权限
revoke select on table student from public;
revoke select on table student from u1 cascade;
```
## 强制存取控制
- 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。
- 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体。
## 安全标准
TCSEC / CC
强度递增
TCSEC : D, C1, C2, B1, B2, B3, A1.
CC : ELA1, ELA2, ELA3, ELA4, ELA5, ELA6, ELA7.
C1 / C2 == ELA2 / ELA3 .
B1 / B2 / B3 == ELA4 / ELA5 / ELA6 .
## 视图
把数据查看权限以视图的方式提供给不同用户，相当于采用视图包装一下，把敏感数据隐藏起来。
## 审计
把用户对数据库的所有操作都记录下来放入审计日志中。
审计级别： 用户级审计，系统级审计。
## 数据加密
### 存储加密
- 透明存储加密：用户可以看见真实信息
- 非透明存储加密：用户看不到真实信息
### 传输加密
- 链路加密：报文报头均加密。
- 端到端加密：只加密报文，不加密报头。
# 数据库完整性
实体完整性，参照完整性，用户定义完整性。
# 关系数据库理论
# 数据库设计
# 数据库编程

## 创建数据库流程实例
### 创建数据库
```sql
CREATE DATABASE SPJ
```
### 创建表
```sql
CREATE TABLE S(
    SNO CHAR(9) PRIMARY KEY,
    SNMAE CHAR(20),
    STATUS CHAR(10),
    SCITY CHAR(20),
);
CREATE TABLE P(
    PNO CHAR(11) PRIMARY KEY,
    PNAME CHAR(20) ,    
    COLOR CHAR(10),
    WEIGHT CHAR(20)
);
CREATE TABLE J(
    JNO CHAR(20) PRIMARY KEY,
    JNAME CHAR(20) ,
    CITY CHAR(10)
);
CREATE TABLE SPJ(
    Sno CHAR(9),
    Pno CHAR(20),
    Jno char(20),
    QIY SMALLINT,
    //主键约束
    PRIMARY KEY(Sno,Pno,Jno),
    //外键约束
    FOREIGN KEY(Sno) REFERENCES S(Sno),
    FOREIGN KEY(Pno) REFERENCES P(Pno),
    FOREIGN KEY(Jno) REFERENCES J(Jno)
)
```
### 
### 



## 1.6 基本概念

* 数据：指具有一定意义的数字，字母，符号和模拟量等的统称，对客观事物的描述。
* 信息：对数据进行提炼加工后的结果。
* 数据和信息的区别：数据是原始材料，信息则是产品。例如：1，3，5，7，9 ··· 是数据，而分析数据后得到的信息则是 ：“首项为 1 ，公差为 2 的等差数列”
* 数据处理：根据已知的数据推导除新的数据，这些新数据得到了新的信息。例如：已知汽车的在某段路上的行驶路程和行驶时间数据，针对这些数据进行处理($\frac{路程}{时间}$) 得到了速度这个新的数据，从而得到新的信息。这个过程就是数据处理。总结一下就是从已知数据推出新的数据从而得到新的信息的过程称为数据处理。
* 数据管理：为了更方便的管理，有效地利用信息资源。需要对数据进行收集，组织，存储，检索和维护等操作。通过对数据进行处理，提高数据的独立性，共享性，安全性和完整性，降低数据的冗余度。使得人们能够方便，有效的利用这些信息资源。

## 1.7 数据管理发展的 3 个阶段

1. 人工管理阶段 
2. 文件管理阶段 
3. 数据库管理阶段 

# 2.0 数据库系统

数据库系统是为了更方便的管理数据而出现的。向应用程序提供数据，存储介质，处理对象和管理系统的集合体，包含的范围比较大。

## 2.1 数据库系统的组成

数据库系统一般由**硬件**，**数据库**，**操作系统**，**数据库管理系统**，**数据库开发工具**，**数据库应用系统**，**人员**所构成。

1. 硬件：主机，存储设备，输入输出设备（I/O），计算机网络环境。

2. 数据库：长期存储在计算机内有组织，统一管理的数据集合。集成和共享。

集成可以理解为相关的所有数据都集中在一起形成一个统一的数据整体，而这些数据整体之间的冗余度很低或者没有冗余。

共享的前提是集成，集成后的数据可被多个用户访问采用不同的语言访问。

3. 软件：数据库系统中的软件包含很多，例如数据库管理系统，数据库开发工具以及数据库应用系统。由操作系统统一管理并提供了接口。

数据库管理系统提供了访问数据库的接口，供操作系统和用户使用。用户或者操作系统可以通过这些接口可以实现，创建，查询，更新以及各种数据控制等功能。用户的大部分操作都是通过数据库管理系统来实现的。

数据库管理系统主要功能有：

* 数据库的定义功能：使用数据库定义语言（DDL）可以定义数据库的三级结构，两级映像，数据的完整性约束，保密限制等约束。
* 数据库的操纵功能：使用数据库操作语言（DML）实现操作数据库。操纵主要分为检索（查询）和更新（插入，删除，更新）。
* 数据库的保护功能：主要分恢复，并发控制，完整性控制，安全性控制四个方面。
  * 恢复指一旦数据库遭到破坏能够恢复原貌。
  * 并发控制指访问数据库用户增多时能够保护数据不被损坏。
  * 完整性控制指保证数据的正确性和语义的有效性。
  * 安全控制指防止未授权的用户操纵数据库。
* 数据库的维护功能：数据载入，转换，存储，数据库的改组以及性能监控等功能。
* 数据字典：存放了数据库系统三级结构的定义和数据库运行时的统计信息。

4. 人员：根据开发，管理和使用数据库系统可以将人员分为多种类型。


## 2.2 数据库系统的结构

三级模式体系：**外模式**，**概念模式**和**内模式**。

两级映像：**外模式**和**概念模式**之间，**概念模式**和**内模式**之间均有映像。

1. 外模式

外模式也称为子模式或用户模式，是用户和数据库系统的接口。用户能够看见和使用局部数据逻辑结构和特征的描述。

一个数据库有可以有多个外模式，不同用户的需求不同所使用的外模式也不同，即相同的数据但是在不同的外模式上所展现的形式也是不同的。

外模式保证了数据的安全性，用户只能访问使用权限范围内的数据，而其余数据用户是看不到的。

2. 概念模式

概念模式也称为模式或逻辑模式，是数据库中全部数据逻辑结构和特征的描述。

一个数据库中只有一个概念模式，供所有用户使用。

概念模式一方面定义了数据的逻辑结构，另一方面定义了数据项之间的关系。

3. 内模式

内模式也称为存储模式或物理模式，是对数据物理结构和存储方式的描述。

最近接物理存储上的一层逻辑模式，也是最低级别的逻辑描述。

4. 两级映像

逻辑模式如果改变，只需要修改外模式和逻辑模式之间的映像即可，外模式不需要改变。因为程序是根据外模式来实现的，所以保证了**程序**和**数据**的**逻辑独立性**。

内模式如果改变（例如存储结构改变），只需要修改内模式和逻辑模式之间的映像即可，逻辑模式不需要改变。这一层的映像保证了数据的**物理独立性**。

外模式和逻辑模式之间的映像在外模式中描述，而逻辑模式和内模式之间的映像在内模式中描述。

5. 缺点

数据的三级模式两级映像虽然保证的数据的高度独立性，但是管理和保存三级模式和两级映像的内容，并且数据需要在其中来回流转也随之带来了时间空间上的开销。

# 3.0 数据模型

## 3.1 数据处理三阶段

**现实世界**到**概念世界**再到**数据世界**。 一共三个阶段，逐渐抽象化。

这个过程中数据经历了**两级抽象**。也就是从现实世界到概念世界的抽象，再从概念世界到数据世界的抽象。

三个阶段中不同阶段可以采用不同的模型，而数据模型则是对现实世界数据特征的**抽象**。

1. 概念模型

概念模型是对客观事物及其联系的一种抽象描述。目前采用的是 E-R 模型。通过 E-R 模型实现了数据从现实世界到概念世界的转换，是一个中间层，表示实体与实体间的联系。

概念模型由实体，实体集，属性，实体标识符组成。

在现实世界中实体与实体间往往是存在联系的，两个实体间的联系称为**二元联系**，而多个实体间的联系称为**多元联系**。

二元联系存在三种情况：(1：1) / (1：N) / (M：N)

2. 逻辑模型

逻辑模型对应于数据世界的模型，是实体及其联系的抽象描述。

传统的逻辑模型有层次模型，网状模型和关系模型三种。

逻辑模型中的数据描述分为字段，记录，文件，关键码。

* 字段可以认为是属性或者数据项。
* 记录可以认为是一条数据，多个属性的集合。
* 文件则是记录的集合，也就是多条数据的集合。
* 关键码表示能够唯一标识某一条数据的属性，也称为主键。

3. 物理模型

物理模型用于描述数据在物理存储介质上的组织结构，与硬件相关。

从逻辑模型到物理模型是由数据库管理系统实现的。而概念模型到数据模型是由人们设计的。所以前者不需要考虑数据在物理层面的实现细节。

## 3.2 常见的数据模型

1. 层次模型

层次模型类似于树的结构。而树结构的定义则是：如果没有父节点那么该节点可以作为根节点，其他节点有且仅有一个根节点。

优点：结构简单清晰，查询效率高，良好的完整性。

缺点：节点之间往往是多对多，而层次模型侧重于一对多。存在一个节点对应多个双亲的情况，会导致冗余数据产生。查询时子节点时需要从父节点出发。

2. 网状模型

网状模型可以更好的描述现实世界，存取效率高。但是不容易存入计算机中，结构复杂，数据操作复杂。

3. 关系模型

实体之间的关系通过二维表来表示。每一行称为一个元组，每一列称为一个属性。一个关系不能由相同的元组和相同的属性，也就是不能由相同的行和相同的列。

优点：数据结构简单，清晰易懂。数据独立性高，安全保密，简化流程。

缺点：因为存取路径透明导致查询效率低，需要优化。

存取路径透明表示使用者使用时不需要考虑存取路径。此处的透明并非能够看到清晰的路径，而是透明的，看不到的。具体可以参考这里. [[1]](https://blog.csdn.net/liuchuo/article/details/51986055)

4. 面向对象模型

根据面向对象的语言设计的数据库，目前还处于襁褓之中，面临着标准化的问题。

技术不成熟，理论还需完善，但是可维护性好，只管有效的表达客观时间，能够解决程序语言数据和数据库管理系统对于数据类型支持的不一致性问题。

# 4.0 数据库种类

由于实际数据特性不同，数据库也存在多种类型。

例如：分布式数据库系统，面向对象数据库系统，多媒体数据库系统，空间数据库系统，专家数据库系统，工程数据库系统。

# 5.0 导图

<div aligen="center" > <img src="https://gitee.com/weijiew/pic/raw/master/img/数据库系统概述.png"/> </div>

# 2.0 关系数据库

简单的来说关系数据库是由一堆表格所组成，而其中每一张表格是由关系所构成，体现了实体与实体之间的联系。

实体又是什么？就学生而言，学生是**实体**，而学生的姓名，学号，性别则是属性。

## 2.1 关系数据结构

1. 关系模式

关系模式，在每个关系中都存在，由一个关系名和它的所有属性组成。通常也称关系名为关系模式。

关系名用 R 表示，属性用 A/B/C 表示，而一个关系模式则可以用 $R(A,B,C,D,E)$ 来表示。

**元数**:表头每一列代表一个属性，元数就是属性的个数。也就是表格的**列数**，

**元组**：元组就是一条数据。

**基数**：表格数据**行数**。

元组的集合也就是表格，称为**关系**或**实例**。

关系是规范化的二维表，所以具备以下性质：

* 属性值是**原子**的，也就是不可再分。
* 没有重复元组。也就是不能有重复数据。
* 没有行序。也就是属性之间没有顺序。
* 理论上没有列序，但是使用时一般都有列序。

1. 键

在关系数据库中存在着键。

键通常由**一个**或**多个**属性组成，有时候也称其为**码**或**关键字**。

键的作用是**唯一标识**一个元组。例如个人信息中的身份证，对于人来说是唯一存在的。

键有**超键**，**候选键**，**主键**，**外键**四种类型。

超键指能唯一标识元组的属性或属性组。例如学生记录中的学号 SNO，姓名 SNAME，这两个属性可以唯一标识一个学生。

候选键指一个属性组能够唯一标识一个元组，和超键不同的是超键可以含有多余的属性，而候选键不行，每一个元素都不是多余的。例如还是学生记录中的 学生可以重名的话，那么 SNAME 就是多余的。而 SNO 则是候选键。

如果候选键有多个，那么其中一个就是主键，可以理解为主键组成了候选键，每一个主键都可以唯一的标识一个元组。

外键的定义是：假如存在一个关系 R，其中包含有另一个关系 S 的主键所对应的属性组 F，则称 F 为 R 的外键，称关系 S 为参照关系，关系 R 为依赖关系。

我们知道一个关系是一张表，换句话说外键指的是存在于当前表中的属性是别的表中主键。

3. 关系模式，关系子模式和存储模式

关系模式是对关系的描述，例如对于学生信息而言，其关系模式为 S(SNO,SNAME,AGE,SDPET) 其中 S 为关系模式的模式名，而圆括号中的则是学生的数据结构。

多个关系模式组成了关系模式集，对于关系模式而言，其中的一个具体的关系称为实例。

关系子模式指数据不在当前的关系模式中而是通过外键链接到另外的关系模式中提取到的数据。

存储模式指数据具体在物理设备上的存储方式，因为关系模式键的存在，通常采用散列方法或索引方法实现。如果关系中元组数目较少（100以内）也会采用堆文件方式实现。除此之外还可以堆任意的属性建立辅助索引。

## 2.2 关系操作

关系的本质是集合，所以操作关系本质上是操作集合，其对象结果都是集合。

1. 基本的关系操作

基本的关系操作有查询，插入，删除和更新。

而查询又分为选择，投影，并，差，笛卡尔积，连接，除等。其中前五种为基本操作。其他的操作都可以通过基本操作实现。例如 $1 * 3$ 可以用 $1 + 1 + 1$ 来实现。

2. 关系操作的表示

关系操作分为关系代数和关系演算。前者是通过关系的运算来表达查询，而后者则是通过谓词来表达查询。

而 SQL 语言则是介于关系代数和关系演算之间的结构化查询语言。

## 2.3 关系完整性约束

由于数据库中数据是动态改变的，为了方便维护并且与现实世界一致需要对关系数据库加以约束。

随着时间的变化，数据时刻都遵守这些约束。

1. 域完整性约束

指属性必须遵守该关系中属性的规则，例如百分制的学生成绩不会出现 101 分的成绩，一旦出现就破坏了域完整性约束。是最基本的最简答的约束。

2. 实体完整性约束

现实世界中的实体是可以唯一标识的，一个属性或一组属性都可以标识一个实体。例如通过身份证来唯一标识一个人。现实世界中不会存在完全两个相同的实体。

而实体完整性则指能唯一标识一个实体的属性或属性组不能为空，如果为空就无法标识一个实体了，这与现实相矛盾。

3. 参照完整性约束

在现实世界中实体与实体之间都是存在练习的。

参照完整性指的是一个关系的外键必须是另一个关系的主键，而且外键取值要么为空或者取作为主键的关系中的有效值。

4. 用户定义完整性约束

所有的数据库都支持实体完整性和参照完整性。但是具体到实际上根据实际情况会有特定的约束。例如学生姓名不能为空值。

以上的这些约束是用户自定义的，也就是用户定义完整性约束。

# 3.0 关系代数基本理论

## 3.1 传统的集合运算

并运算，交运算，差运算，笛卡尔积运算。

## 3.2 专门的关系元

选择，投影，连接，除等。

# 4.0 关系数据库的规范化理论

这些理论是为了构建更好的，合适的关系模式出现的。

根据现实世界的数据依赖从而对关系模式进行规范化处理，主要是解决不合适的数据依赖问题，数据依赖指的是数据之间的各种联系。

## 4.1 关系模式规范化的必要性

如果没有关系模式规范化会出现很多问题。例如数据冗余，指同一个数据在系统中多次出现。

因为数据冗余还会导致操作异常，操作异常分为更新异常，插入异常，删除异常。也就是当变更某个数据时需要将涉及到的所有的表都变更一遍，一旦没有变更使得同一个数据在不同的表中的值不一致都会导致异常出现，而根据变更的方式出现了更新异常，插入异常，删除异常。

## 4.2 函数依赖

1. 什么是函数依赖

先看例子：在学生这个关系中，通过学号可以确定学生的姓名，那么就说明姓名依赖于学号或者说学号决定姓名，这就是函数依赖。

定义：假设 R(U) 是一个关系模式，U 是 R 的属性集合， X，Y 是 U 的两个属性子集。对于 R(U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性级相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记做 $X \rightarrow Y$，称 x 为决定项，y 为依赖项。

其中入过 Y 是 X 的子集，也就是 $y \subseteq x$ 那么必有 $X \rightarrow Y$ ，这是平凡函数依赖，反之其他的都是非平凡函数依赖。

关于函数依赖的概念还要注意以下几点：

* 函数依赖不是指关系 R 的部分关系实例需要满足而是全部都需要满足。

* 函数依赖是语义层面的概念，具体情况具体分析。

* 数据库的设计者需要根据实际情况设计函数依赖避免在使用种出现错误，不符合函数依赖的数据就不能存入数据库中。

2. 完全函数依赖和部分函数依赖

例子:

定义：从函数依赖继续向下分析，在关系模式 R(U) 中如果 $X \rightarrow Y$ 而对于 X 中的任一个真子集 W ，都有 $W \rightarrow Y$ 不成立，那么称 Y 完全函数依赖，反之就是部分函数依赖。

如果 U 部分函数依赖于 X 那么 X 是 R 的一个超键，反之如果 U 完全函数依赖于 X ，那么 X 是 R 的一个候选码。也就是超键里面存在多余的属性而候选键里面没有多余的属性。

3. 传递函数依赖

定义：在关系模式 R(U) 中，有 X，Y，Z 三个子集，如果 $X \rightarrow Y$ 而 $Y \rightarrow Z$ 那么称 X 传递函数确定 Z。而 Z 传递函数依赖 X 。

4. Armstrong 推理

根据已知的函数依赖推导出另外的函数依赖需要一些规则的支撑，而 Armstrong 公理提供了这些规则。

Armstrong 有以下三条规则：
* 自反性：如果 $B \subseteq A$ 则 $A\rightarrow B$  
* 增广性：如果 $A \rightarrow B$ 则 $AC \rightarrow BC$
* 传递性：如果 $A \rightarrow B$ 并且 $B \rightarrow C$ 那么 $A \rightarrow C$

根据 Armstrong 可以得到以下推论：
* 合并性：如果 $A \rightarrow B$ 且 $A \rightarrow C$ 那么 $A \rightarrow BC$ 
* 分解性：如果 $A \rightarrow BC$ 那么 $A \rightarrow B$ 且 $A \rightarrow C$ 
* 伪传递性：如果 $A \rightarrow B$ ， $BC\rightarrow D$ 那么 $AC\rightarrow D$
* 复合性：如果 $A\rightarrow B,C \rightarrow D$ 那么 $AC\rightarrow BD$

对于关系模式而言可能存在多个函数依赖，这些函数依赖构成的集合称为 F。

如果两个函数依赖集 $F_{1} F_{2}$ 在 Armstrong 公理的推导下相同则称 $F_{1} F_{2}$ 对于 Armstrong 推理保持一致。 

## 4.3 关系的范式及规范化

如果数据库中的表（关系模式）设计不好是会存在很多问题的，例如数据冗余，操作异常。

但是设计出好的关系范式必须满足一定的约束条件，这些条件成就是关系模式的规范。

规范的严格程度分为多个级别，不同级别之间严格递进，其中而每一个级别都称为范式。

1. 第一范式

举个例子：在客户这个关系模式中，如果电话号码这个属性可以再分话，例如一个客户有两个电话号码。

那么必定需要存两条记录了，首先就破坏了主键约束，即主键唯一标识一条记录，也就是同一个客户存在两条记录。

除此之外会带来数据的冗余，插入删除更新等操作数据时更要避免数据出现异常。所以问题在于字段属性只能有一个含义，属性不可分解，原子级别。

定义：第一范式指关系模式中的属性不可再分，也就是原子级别的。

第一范式 (first normal form) 简称 1NF 。

2. 第二范式

定义：在关系模式 R 中，首先 R 属于 1NF，其次它的每一个非主属性都完全函数依赖与 R 的候选键，那么 R 属于第二范式，简称 $R\subseteq2NF$ 。

3. 第三范式

定义：如果关系模式 R 属于 1NF ，且每个非主属性都不传递依赖于 R 的候选键，那么称 R 属于第三范式，简记为 $R\subseteq3NF$

注意 满足 3NF 的前提是已经满足了 2NF ！

将关系模式分解到这种地步已经很大程度上的降低了数据冗余和操作异常。

4. BC 范式

定义：如果关系模式 R 是 1NF，且每个属性都不传递依赖于 R 的候选键，那么称 R 属于 BC范式，也就是 $R\subseteqBCNF$

BC 范式和第三范式的区别在于，前者既检查主属性，又检查非主属性。而后者只检查非主属性。

显然 BC 范式更为严格，并且满足 BC 范式的话一定满足第三范式。

如果一个数据库中关系模式都是 BC 范式的话，在函数依赖范围内已经实现了彻底的分离。

并且已经消除了插入和删除异常，3NF 的“不彻底性” 表现在可能存在主属性对键的部分依赖和传递依赖。


## 4.4 关系模式的分解

模式分解指的是将原有关系在不同属性上进行投影，从而将原有的一个关系多个属性分解成多个关系，其中的每个关系含有较少属性。

并且分解必须是可逆的，可逆意味着信息没有丢失，数据间的语义联系依旧存在。

1. 无损分解

指对新的关系进行自然连接后得到的元组集合与原关系完全一致，如果不一致则称为有损分解。

2. 保持函数依赖分解

指分解后的函数依赖对于 Armstrong 推理保持一致。

3. 关系模式分解原则

指保证数据等价和语义等价以及效率。

无损分解可以保证数据等价，也就是通过连接可以逆转，分解前后数据不会丢失。

函数依赖分解可以保证语义等价，分解前后语义不发生变化。

除此之外还要考虑效率问题，如果分解的太细做大量的连接运算会减低查询速度。

可以适当的增加数据冗余，以空间换时间。

4. 3NF 分解

理论上已经证明任何关系模式都可以无损分解为多个 3NF ，并且这会解决数据冗余和操作异常等问题。
