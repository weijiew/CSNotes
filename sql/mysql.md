# MySQL 架构与历史

MySQL 最大的特点在于其架构的**灵活性**，配置后可以适用于非常多的场景下。

MySQL 的灵活体现在多个方面，例如支持多种数据类型，通过可以在不同的硬件上良好运行。

MySQL 最重要的特点是它的存储引擎架构，该架构将数据**查询及其其他系统任务**和数据**存储和提取**相分离。

这种**处理**和**存储**分离的设计使得在使用时可以根据性能，特性以及其他需求来选择数据存储方式。

# 1.1 MySQL 逻辑架构

MySQL 逻辑架构分为三层：

<div align="center"><img src="https://gitee.com/weijiew/pic/raw/master/img/20200719151615.png"/></div>

顶层的是客户端，不是 MySQL 独有的，提供使用接口，例如连接处理，授权认证，安全等功能。

中间一层则是 MySQL 的核心服务层，提供了功能例如查询解析，分析，优化，缓存以及其他内置函数。而存储过程，触发器，视图等跨存储引擎的功能也都在这里实现。

底层则是存储引擎，存储引擎之间的差异是比较大，但是存储引擎提供了接口（API）同服务器进行通信。这些接口抹平了不同存储引擎之间的差异。

存储引擎实现了几十个函数，例如“提取某条记录”，“开启某个事物”等功能。存储引擎不会解析 SQL 语句且存储引擎之间不会进行通信，只是简单的响应上层服务器的请求。

## 1.1.1 连接管理与安全性

每个客户端都拥有一个线程，CPU 执行该线程去连接 MySQL 服务器，然后根据用户名，密码来判断是否有权限访问。通信过程使用 SSL 加密，或者 X.509 证书认证。

当不使用该线程时服务器会缓存该线程，而不是为每一个新建的连接创建或者销毁线程。

和 MySQL 服务器建立链接后，服务器会继续判断该客户端是否有权限执行某个特定查询的权限，也就是判断是否有权限执行对某个数据库中的某张表有操作的权限。

## 1.1.2 优化与执行

MySQL 会解析查询，创建解析树对其进行各种优化处理。例如重写查询，决定表的读取顺序，以及选择合适的索引等。

用户也可以设置相应的关键字来调整优化器，影响其决策。也可以将优化器的优化过程体现出来，使得我们可以明白优化原因。

优化器不用考虑存储引擎的不同，但是存储引擎的不同对优化查询存在影响。存储引擎需要提供该引擎的具体信息，例如存储引擎容量，具体某个操作的开销，表数据的统计信息等。某些存储引擎的某种索引对于特定查询可以进行优化。

执行 SELECT 语句时，服务器会先去**检查缓存**，如果缓存中存在对应的查询那么就直接返回不再执行后续**查询解析**，**优化**和**执行**的整个过程。

# 1.2 并发控制

当多个查询在同一时刻下修改数据都会产生并发控制的问题。

可以从服务器层和存储引擎层来考虑并发控制问题。

例如：当两个进程同时对一个邮箱投递邮件时如果不加控制会导致二者信息混杂，二者数据都被破坏。

常规的做法是加锁，一个进程向邮箱投递邮件时会加锁表示正在投递中，当另外一个邮件在此时此刻也想向邮箱中投递发现了锁的存在会等待，直到另外一个邮箱执行完毕后再投递自己的邮件。

锁的缺点是不支持并发，任意一个时刻只允许一个进程可以修改邮箱中的数据。

## 1.2.1 读写锁

多个进程读取同一段数据是可以的，也就是单纯的读是可以共享的。

但是读和写混杂是会产生麻烦的，当读取某段数据的同时也修改了这段数据，读取到的是修改前的还是修改后的就无从得知了。解决这类问题是通过并发控制来实现的。

并发控制设置了**共享锁**和**排他锁**，也成为**读锁**和**写锁**。

读锁是**共享**的，多个客户端互不阻塞，同一时刻下可以读取同一个资源。

写锁是**排他**的，一个写锁会阻塞其他的写锁和读锁。这样设置确保了防止其他用户读取正在写入的同一资源。

## 1.2.2 锁粒度

加锁时，锁定数据的**范围**也是有讲究的。例如为了修改某个数据锁定了一张表，或者锁定该数据所在的行。这就是差别，也称锁的**粒度**，明显前者的粒度大于后者。

锁定的数据量越少，**锁粒度**越小，**并发程度**越高。

执行加锁，解锁等各种相关操作是会增加系统开销的，如果系统花费大量的时间来管理锁而非处理数据那么势必会影响系统的性能。

锁策略就是在锁的开销和数据的安全性之间寻求平衡。一般情况下都是在表上施加行级锁。

MySQL 提供了多种存储引擎，每种存储引擎都有自己的锁策略和锁粒度，在不同的场景下可供使用，以提供良好的性能。

### 表锁

表锁是**开销最小的锁**，（因为范围大）会直接锁定整张表。当执行写操作时会先获得写锁，然后将其他的读写锁都阻塞，直到写操作执行完毕释放写锁为止。只有没有写锁时读写锁才是互不阻塞的。

在特定场景下表锁具有良好的性能。写锁的优先级大于读锁，当写锁出现在队列中即使之前有读锁存在依旧会优先执行写锁。

存储引擎管理自己的锁，而 MySQL 本身也会使用有效的表锁来实现不同的目的。

### 行级锁

行级锁支持**最大程度的并发**，范围小了开销就比表锁大了。

行级锁只在存储引擎层实现，没有在 MySQL 服务器层实现。

服务器层是完全不了解存储引擎中的锁实现。

# 1.3 事务

可以将事务理解多组 SQL 查询语句，执行时要么全部执行，如果执行到一般崩溃或出错那么全部语句都不执行，也就是遵守原子性。

事务具有 ACID 特性，也就是原子性，一致性，隔离性，持久性。

* 原子性：事务为最小工作单元，不可分割。
* 一致性：从一个状态转换为另外一个状态，不存在中间状态，例如执行语句时崩溃了，那么还停留在第一个状态，之前执行的语句都无效。
* 隔离性：事务在最终执行完之前对外是不可见的。
* 持久性：一旦事务提交，该事务所做出的改变永久的保存在数据库中。

要做到 ACID 是非常难的，需要做很多复杂的工作才能确保实现，这个过程也会增加系统开销，对硬件存在一定的要求。

## 1.3.1 隔离级别

隔离级别比想象中复杂，在 SQL 标准中分为四个级别，存储引擎不同隔离级别也不尽相同。

* READ UNCOMMITTED ： 未提交读，也就可以读取未提交事务的数据，也称为**脏读**，有好处但是坏处更大，较少使用。
* READ COMMITED ： 提交读，也就是在事务提交之前所作的修改都是不可见的，只能看见已经提交的事务，也成为不可重复读取，因为存在相同查询但是结果不同的情况。大多数数据库系统的默认隔离级别是这样的，但是 MySQL 不是。
* REPEATABLE READ ： 可重复读，解决了脏读问题，但是存在幻读问题。所谓幻读就是读取前后插入了新的行记录导致再次读取信息产生了幻行。InooDB 和 XtraDB 储引擎通过多版本并发控制解决了该问题，MySQL 的默认事务隔离就是这个。
* SERIALIZABLE ： 可串行化，最高的隔离级别，对读取的每一行数据都枷锁避免了幻读问题，但是可能会导致大量超时和锁争用问题。常规下是不使用的，只有在非常需要确保数据一致性且接受没有并发的情况下才会考虑。

## 1.3.2 死锁

解决死锁的方式有两种，一种是死锁检测，另外一种则是死锁超时机制。

死锁超时指等待该锁达到一定时间后就放弃，但是通常不太友好。而死锁检测则是检测要死锁的循环依赖就马上报错，速度快。

死锁产生分两种类型，一类数据冲突，这个难以避免，另一类则指存储引擎的实现方式导致死锁。

处理死锁时只需要回滚其中一个事务即可打破死锁，所以设计时需要考虑如何处理死锁。

## 1.3.3 事务日志

采用事务日志可以提高效率。当数据发生改动时可以先提交到事务日志中，积累到一定的量后在一次性提交到持久化到磁盘上，而不是每次都持久化到磁盘中。

事务日志采用追加式，当新的操作执行完毕后会附加到事务日志中。

在磁盘的中会开辟一块**顺序**的空间用于存放事务日志，这样避免频繁移动磁头，提高了读写效率。

当系统发生崩溃时，如果数据已经存入事务日志中但是还没有持久化带磁盘中。重启系统后可以根据存储引擎来从事务日志中恢复数据，具体恢复方式视存储引擎来定。

## 1.3.4 MySQL 中的事务

MySQL 提供了两种事务型的存储引擎：InnoDB 和 NDB Cluster 。 除此之外还有一些第三方的存储引擎 XtraDB 和 PBXT 也支持事务。

### 自动提交

### 在事务中混合使用存储引擎

事务是在存储引擎中实现的，但是不同的存储引擎存在差异，所以同一个事物在多种存储引擎中是不可靠的。

### 隐式和显式锁定

InnoDB 采用的是两阶段锁定协议。

# 1.4 多版本并发控制



# 1.5 MySQL 的存储引擎

## 1.5.1 InnoDB 存储引擎

## 1.5.2 MyISAM 存储引擎

## 1.5.3 MySQL 内建的其他存储引擎

## 1.5.4 第三方存储引擎

## 1.5.5 选择合适的引擎

## 1.5.6 转换表的引擎

# 1.6 MySQL 的时间线

# 1.7 MySQL 的开发者模式

# 1.8 总结