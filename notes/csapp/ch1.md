# 第一章：计算机系统漫游

计算机系统是由**硬件**和**系统软件**组成，二者共同工作来运行应用程序。

虽然硬件和系统软件的实现方式随着时间的改变是不同的，但是**概念**却是不变的。

通过了解这些概念可以明白这些组件是如何影响程序的正确性和性能，以便于提高自身技能。

本质上来说，这本书就是讲代码从编写到运行所经历的过程。

例如使用 C 语言编写一段代码（hello.c）到最终运行出来的过程。

通过这个过程可以了解到系统**发生了什么**以及**为什么会这样**。

```cpp
#include <stdio.h>
int main() {
    printf("hello world\n");
    return 0;
}
```

后续部分就是讲 hello 程序从编写到运行，最终输出内容这个过程中涉及到的东西。

# 1.1 信息就是位 + 上下文

程序是通过编写**源代码**开始的，源代码本身则是**字符**组成。

代码虽然都是字符，但是运行的源程序实际上是由 0 或 1 组成。

8 个 0/1 的组合构成一组，称为**字节**，而字节则表示程序中的一个**字符**。

ASCII 标准是常见的编码方式，每个字符都对应着相应的数字。例如字符 # 表示十进制下的 35 。

每行代码的末尾都**隐式**的存在一个**换行符** '\n' 。

# 1.2 程序被其他程序翻译称不同的格式

C 语言是**高级语言**，是便于人使用，阅读的产物。但是机器只能读懂 0/1 ，也就是二进制的信息。所以 C 语言需要经过**翻译**，最终变成 CPU 可以识别的**二进制形式**的**可执行文件**，也就是程序。

从编写好的代码到变成真正的程序会进行**预处理**，**编译**，**汇编**和**链接**几个步骤，最终产生一个**二进制**形式的**可执行文件**。

* **预处理阶段**，预处理机（cpp）会将以字符 # 开头的代码修改为原始的 C 程序。以 # 开头代码实际上是调用 C 语言编写好的库代码。例如 `#include <stdlib.h>` 表示调用系统头文件 `stdlib.h` 中的代码，可以理解为将代码插入当前位置。然后会产生一个扩展名为 .i 结尾的文件。例如 hello.i 。当前阶段就执行完了。
* **编译阶段**，编译器（ccl）会将文本文件 hello.i **翻译**成文本文件 hello.s 。也就是翻译成汇编语言。
* **汇编阶段**，汇编器（as）会将文本文件 hello.c 翻译成二进制文件 hello.o 。注意这个二进制文件中只包含函数 main() 中的指令。
* **链接阶段**，连接器（ld）会将程序涉及到的文件链接起来，因为调用了输出函数 `printf()` ，而该函数存在于 C 函数库中`printf.o` 文件内，所以连接器会将其整合起来形成 hello 文件，这就是一个可执行文件。

经过上面的四个阶段后，将最终产生的可执行文件载入内存中，由系统执行。

# 1.3 了解编译系统如何工作是大有益处的

编译系统将 C 语言转换成机器代码的过程中是容易产生问题的。

除此之外了解汇编过程是非常有用的，通过查看机器码以及编译方式可以更细粒度的明白哪些 C 语言编写方式执行起来更快速。

例如 switch 和 if-else 的组合哪个更高效，函数调用的开销多少，while 循环和 for 循环那个更快等等。

理解链接时出现的错误。避免程序在连接时可能或产生错误。

避免安全漏洞。编写更为安全的代码。

# 1.4 处理器读并解释储存在内存中的指令。

下一步就是执行 hello 文件了。

通过 shell 来执行文件，可以直接键入文件名来执行。

shell 是一个命令解释器，输入命令，然后执行。

当输入一个命令后 shell 首先会判断该命令是不是内置的 shell 命令。

如果是就按照设定的执行，如果不是则假设是可执行文件的名字，然后加载并运行该文件。

## 1.4.1 系统的硬件组成

了解执行 hello 程序运行过程需要先了解系统的硬件组成。

1. 总线

总线负责携带信息字节在各个部件之间传递。如果将信息理解成水流的话，那么总线就是管道。

通常总线是运送的是定长的字节块，也就是字。字有长度，也就是字长，指字节数。字长通常有 4 个字节或者 8 个字节。也是 32 位或 64 位。

2. I/O 设备

系统同外界交互的渠道，常见的 I/O 设备有鼠标，键盘，显示器，以及磁盘等。

I/O 设备通过**控制器**或者**适配器**和 I/O 总线相连。

控制器和适配器随有不同，但是二者都是承担 I/O 设备和 I/O 总线之间传递信息的作用。

3. 主存

主存指临时存储器，用来存放程序或程序处理的数据。

物理上主存是由动态随机存取存储器组成，逻辑上主存就是线性的字节数组。

4. 处理器

处理器即 CPU，中央处理单元。

## 1.4.2 运行 hello 程序

通过编译器已经生成了一个 `hello` 可执行程序。但是如何操作系统是如何运行该程序的？

首先执行该程序的命令是从键盘敲入 shell 中的。然后通过 shell 来执行此命令。

> 例如将指令 `./hello` 敲入 shell 中。shell 去执行。

之后 shell 将指令字符逐个读入寄存器中，然后再返回内存。（也就告诉 CPU 去执行该文件）。

**直接存储器技术**可以不通过处理器而直接将数据从**磁盘**复制到**主存**中。

shell 通过 CPU 将命令翻译成指令，首先将目标文件 `hello` 从磁盘复制到主存中。

然后处理器开始执行 hello 程序，因为 hello 已经被翻译成了机器语言的指令，所以直接将其复制到寄存器中即可。

CPU 执行该文件，继续将**寄存器**文件中要显示的 "hello,world\n" 字符复制到**显示设备**中，最终输出到屏幕上。

# 1.5 高速缓存至关重要

执行程序时需要不断的复制程序，从磁盘到主存，从主存到寄存器，再从寄存器到显示设备上。

不断的复制意味着不断的开销，降低了运行程序的效率。

主存和寄存器之间的速度差别比较大，主存虽然存的多但是读取速度慢，而寄存器则相反虽然存的少但是读取速度快。

为了降低主存和寄存器之间的差异，在中间引入了高速缓存，作为中间的临时中转。

高速缓存也分为多个级别，L1，L2 和 L3 。读写速度依次降低，L1 的读写速度和寄存器一样，进程访问 L2 时要比 L1 的慢 5 ~ 10 倍，L3 则更慢。

高速缓存利用了**局部性原理**。局部性原理值程序具有访问局部区域里的**数据**和**代码**的趋势。

将存放经常访问的数据存放在**高速缓存**中可以将程序的性能提高一个量级。

# 1.6 存储设备形成层次结构

计算机中的存储设备有：寄存，L1/L2/L3 高速缓存，主存，本地磁盘，远程磁盘。

其**速度**由高到底逐渐降低，反之单位造价内**存储空间**逐渐增加且**便宜**。

可以将寄存器理解为 L1 的高速缓存，而 L1 则作为 L2 的高速缓存，L2 是 L3 的高速缓存，依次逐渐递推。

# 1.7 操作系统管理硬件

shell 在执行指令的时候并没有直接在硬件上操作，而是操作系统提供了相应的接口。shell 通过接口来和操作系统进行交互。

所以由此可以理解操作系统是在应用程序和硬件直接提供了一层软件。

操作系统的两个功能：

1. 防止硬件被失控的应用程序滥用。 （保护硬件）
2. 向应用程序提供简单一致的机制来控制复制而又通常大不相同的低级硬件设备。

操作系统对实现了一些低级的抽象：进程，虚拟内存和文件。
* 文件是对 I/O 设备的抽象表示。
* 虚拟内存是对主存和磁盘 I/O 设备的抽象表示。
* 进程则是对处理器，主存和 I/O 设备的抽象表示。

## 1.7.1 进程 

> 进程是操作系统对一个正在运行程序的抽象。

操作系统通过在多个进程中不断切换实现了一个系统可以运行多个程序。（单核处理器）

但是在同一时刻内，进程只处理一个程序，频繁的切换使得看起来多个程序在运行。这种不断切换机制称为**上下文切换**。

这种看起来多个程序同时运行的方式称为**并发运行**。

操作系统在进行切换时会保存该进程运行的**状态信息**，从而保证了下次可以在切换的位置再切换回来。这种状态信息也称为**上下文**。

控制进程切换功能的是操作系统内核，内核不是一个独立的进程，常驻再内存中的部分，系统管理全部进程所用代码和数据结构的集合。

## 1.7.2 线程

进程的内部可以存在多个线程，在同一个进程中线程与线程之间的数据是共享的。但是进程与进程之间的数据却是封闭的。

进程是分配资源的最小单位，而线程则是 CPU 调度的最小单位。

相比进程线程的粒度更细，线程消耗的资源要少于进程。

一个程序最少有一个进程，一个进程最少有一个线程。

## 1.7.3 虚拟内存

虚拟内存为每一个进程提供了可以独占使用主存的假象。其内部的主存是一致的，称为虚拟空间地址，可以将其理解为“数组”。

虚拟内存分为多个部分，地址空间最上面的区域是六个操作系统中的代码和数据的。底部则用来存放用户进程定义的代码和数据。

## 1.7.4 文件

文件就是字节序列，信息都可以看出是文件。

通过输入输出设备来对 调用 I/O 函数实现了对数据的交互。

不同的磁盘存储技术的不同的，在没有文件系统之前，程序员需要对磁盘技术了解才能存取文件。

但是文件系统对不同的磁盘技术进行的封装，程序员可以不需要了解磁盘使用技术就能够实现数据的存取。

# 1.8 系统之间利用网络通信

系统是孤立的，通过网络适配器实现了不同系统之间的通信，也就是网络的原型。

其本质就，将主存中的数据复制到网络适配器中，网络适配器再将数据发送到别的系统中。同理也通过网络适配器接受数据，将数据复制到主存中。

# 1.9 重要主题

系统不仅仅是硬件，而是软件和硬件的结合。

## 1.9.1 Amdahl 定律

在一个系统中，想要显著加速整个系统，必须提升全系统中相当大的部分的速度。

其实和木桶理论很像，木桶盛水量的多少取决于短板。

## 1.9.2 并发和并行

计算机如何运行的更快，做的更多是发展的方向。

并行和并发不同的地方在于并行在同一时间被却是存在多个程序在一块运行。

超线程技术实现了一个核可以执行两个线程。


## 1.9.3 计算机系统中抽象的重要性

抽象是很重要的概念，例如编程时的 API 。无需了解细节实现，会用就行。

同理在操作系统中：

* 文件是对 I/O 设备的抽象。
* 虚拟内存则是程序存储器的抽象。
* 进程则是对一个正在运行的程序的抽象。
* 虚拟机则是对整个计算机中抽象。

# 1.10 小结

* 计算机由硬件和软件组成。
* 计算机内部的信息被表示成位，根据上下文解释翻译成不同的形式，从 ASCII 文本最终翻译成二进制文件。
* 处理器在不同存储器中复制指令带来的消耗引入了高速缓存。
* 操作系统是硬件和应用程序之间的媒介。
* 网络为不同的计算机系统之间提供了交互的方式，其本质也是 I/O 设备。

